<!DOCTYPE html>
<html>
    <head>
        <title>Firmware : CAN (Control Area Network)</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Firmware</a></span>
                            </li>
                                                    <li>
                                <span><a href="Firmware_9465365086.html">Firmware</a></span>
                            </li>
                                                    <li>
                                <span><a href="Documentation_9513894334.html">Documentation</a></span>
                            </li>
                                                    <li>
                                <span><a href="Common-all-Documentation_9569468768.html">Common-all Documentation</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Firmware : CAN (Control Area Network)
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Former user</span>, last modified by <span class='editor'> Owen Brake</span> on Jan 23, 2021
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <div class="contentLayout2">
<div class="columnLayout single" data-layout="single">
<div class="cell normal" data-type="normal">
<div class="innerCell">
<h1 id="CAN(ControlAreaNetwork)-CANintheFirmware">CAN in the Firmware</h1><p>In our firmware, we have setup a multi level toolchain to help abstract the lower level details of CAN. This is composed of multiple parts, from lowest to highest level they are:</p><ol><li>The ST HAL CAN Driver</li><li>Our CAN driver in the common-all submodule, composed of:<ol><li>A driver for F0</li><li>A driver for F7</li><li>A driver on top that call into either F0 or F7</li></ol></li><li>A python script to automatically generate a pair of .c/.h files for each board that describes its CAN messages</li><li>A vector CANdb database that describes the CAN messages for the entire car</li></ol><p><br/></p></div>
</div>
</div>
<div class="columnLayout single" data-layout="single">
<div class="cell normal" data-type="normal">
<div class="innerCell">
<h1 id="CAN(ControlAreaNetwork)-CANDB">CAN DB</h1><p>The vector CANdb format consists of three main components, the ECUs/Nodes, messages, and signals. ECUs/Nodes are the different boards on the CAN bus that send and receive CAN messages. </p><h2 id="CAN(ControlAreaNetwork)-Signals">Signals</h2><p>Signals are individual bits of data, such as a cell voltage, wheel speed, etc. <span style="letter-spacing: 0.0px;">An important point to note about signals is that there is two different representations for a signal, the engineering representation, and raw representation. For example, for a cell voltage of 5.1 Volts , the engineering representation would be 5.1 (note that this is a floating point value). The raw value can't be floating point, so a scale and offset is applied to convert it to a singed/unsigned integer. For example a scale of 0.1 and offset of 3 could be used, giving 21 (offset is first subtracted, then you divide by the scale to convert to raw value).</span></p><h2 id="CAN(ControlAreaNetwork)-Messages">Messages</h2><p>Messages are a combination of multiple different signals that all fit in the 8 bytes of a CAN message. The same signal can be used in multiple messages, and the same message can be sent by multiple nodes. Each message has an associated ID. Since we are using J1939 CAN, the ID consists of multiple fields, outlined in this page: <a href="https://uwaterloo.atlassian.net/wiki/spaces/FEEL/pages/6524672668/CAN+BUS" data-linked-resource-id="6524672668" data-linked-resource-version="8" data-linked-resource-type="page">CAN BUS</a>.</p><p>In our CANdb, we have defined multiple types of CAN messages. These are normal messages, DTC messages, multiplexed messages, and PROCAN messages.</p><p>Normal messages are those that don't have any of the special features of the other messages types.</p><p>DTC messages are used to communicate faults that occur on the car. See the DTC section on this page for more info. </p><p>Multiplexed messages are messages that contain variable data. What data they contain is indicated by a fixed signal that is always present in the message. For example, there is a multiplexed messages containing cell voltage. There is a multiplexer signal which specifies which group of cells the message contains voltages for. The other three signals in the message are the multiplexed cell voltages. If the multiplexer signal has a value of 1, then the three cell voltage signals would have the voltages for cell 4,5, and 6 (assuming cell 1 is the first cell, ie one based numbering instead of zero based numbering).</p><p>Finally, PROCAN messages are messages following the PROCAN protocol used to communicate with the motor controllers. See the <a href="Motor-Controllers_9479061506.html" data-linked-resource-id="9479061506" data-linked-resource-version="2" data-linked-resource-type="page">motor controller page</a> for more information on PROCAN</p><h1 id="CAN(ControlAreaNetwork)-ThepythonScriptandautogeneratedCANsourcefiles">The python Script and autogenerated CAN source files</h1><p>The python script converts the Vector CANDb++ database into c code to run on each board. This is done with the help of the <a class="external-link" href="https://cantools.readthedocs.io/en/latest/" rel="nofollow">can tools</a> python library which parses the Vector CANdb++ database. This c code consists of a pair of .c/.h files (except for the BMU which has another pair of .c/.h files for communicating on its charger CAN bus). The c files allow the board to send and receive all the messages specified as being sent/received by the board in the CAN database, as well as parsing the messages into signals.</p><p><span style="letter-spacing: 0.0px;">The c files also set up the CAN driver with filters that cause it to only receive certain CAN messages. The filters are (see the <a href="https://uwaterloo.atlassian.net/wiki/spaces/FEEL/pages/6524672668/CAN+BUS" data-linked-resource-id="6524672668" data-linked-resource-version="8" data-linked-resource-type="page">CAN BUS</a> page for more info on CAN addresses): </span></p><ul><li><span style="letter-spacing: 0.0px;">The broadcast filter, for messages with destination address 0xFF</span></li><li>The board filter, for messages with destination address equal to the boards CAN address</li><li>Message group filters (can be multiple): one filter per message group the board belongs to, each filter looks for the destination address equal to the message group &lt;&lt; 4</li></ul><h2 id="CAN(ControlAreaNetwork)-Templating">Templating</h2><p>The python script was updated in 2021 to use python templates. Rather than hardcoding in each line, templates are loaded in on the fly and filled in with provided data. Scripts/templateLoad.py is the built in house template library used, it loads in text templates from Scripts/templates/&lt;insert_name_here&gt;.txt. The loader library just uses the builtin python templating system, it converts the files into a Template object and fills those template with the provided data using Template.substitute().</p><h3 id="CAN(ControlAreaNetwork)-AddinganewTemplate">Adding a new Template</h3><ol><li>Create a text file in Scripts/templates/&lt;insert_folder_here&gt;/&lt;insert_template-here&gt;.txt.<ol><li>Fill it with whatever template data you want to use</li><li>To reference a variable to be filled in use ${variableNameHere}</li></ol></li><li>Add a &lt;key,value&gt; to TEMPLATE_MAP in Scripts/templateLoad.py<ol><li>key should be whatever you want to reference it as in the code, value is the location of the template relative to templateLoad.py.</li></ol></li><li><p class="auto-cursor-target">You can now call the load function</p><ol><li>In generateCANHeader.py this is &quot;canTemplater.load(...)&quot;</li></ol></li></ol><h2 id="CAN(ControlAreaNetwork)-UsingtheautogeneratedCANSourcefiles">Using the autogenerated CAN Source files</h2><p>The autogenerated can source files are located in the Gen directory. They are called &lt;board_name&gt;_can.h and &lt;board_name&gt;_can.c</p><h2 id="CAN(ControlAreaNetwork)-InitializingtheCANdriver">Initializing the CAN driver</h2><p>In order to use the autogenerated CAN source files, it is necessary to initialize the CAN driver. This is done by calling a few functions from the common-all userCan.h file. First, before the RTOS starts (so in userInit.c) call canInit specifying the Cube CAN handle:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: cpp; gutter: false; theme: Confluence" data-theme="Confluence">canInit(&amp;CAN_HANDLE)</pre>
</div></div><p class="auto-cursor-target">Next, once the RTOS starts, in any task that needs CAN call canStart. This allows you to send CAN messages, and starts receiving CAN messages.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: cpp; gutter: false; theme: Confluence" data-theme="Confluence">canStart(&amp;CAN_HANDLE)</pre>
</div></div><h2 class="auto-cursor-target" id="CAN(ControlAreaNetwork)-SendingCANMessages">Sending CAN Messages</h2><p>In order to send a CAN message, you first need to configure the signals present in the message. This is done by setting the global variables representing the signals to the desired value (note: as of 2020 this is being changed to setting signals through functions). Once the signals are configured, you then call the sendCAN_&lt;message_name&gt;() function.</p><h2 id="CAN(ControlAreaNetwork)-ReceivingCANmessages">Receiving CAN messages</h2><p>In order to receive, you need to define a callback for that message. The callbacks are defined in the autogenerated source file, and declared as weak linkage. Therefore, simply redefine the callback for the message you wish to receive with the desired behaviour. In the callback, you can access the signals in the received message through their global variables.</p><h2 id="CAN(ControlAreaNetwork)-AddinganewCANmessage">Adding a new CAN message</h2><p>In order to add a new CAN message, the dbc file in the common-all data directory is modified (called 2018CAR.dbc for the 2018-2020 car). The general process is as follows, but see the VectorCANdb++ documentation for more details:</p><ol><li>Open the dbc file of the board that will be sending the message in the vector CANdb++ editor. See this <a href="9497477838.html" data-linked-resource-id="9497477838" data-linked-resource-version="13" data-linked-resource-type="page">page</a> on getting CANdb++ setup.</li><li>Add any necessary new signals (you can also reuse existing signals in a new messages. Select signals, right click and select new. The important fields to fill out are:<ol><li>Name: signal name</li><li>length: number of bits used to store the raw representation</li><li>Byte order: set to intel</li><li>Value type: in general, use unsigned and use scalar and offset to represent fractional values and negative values</li><li>Unit: Unit of the engineering value</li><li>Factor and Scale: Select such that the expected range of engineering values is converted </li></ol></li><li>Add the message (right click messages→new)<ol><li>Name: message name</li><li>Type: always CAN extended</li><li>ID based on the <a href="https://uwaterloo.atlassian.net/wiki/spaces/FEEL/pages/6524672668/CAN+BUS" data-linked-resource-id="6524672668" data-linked-resource-version="8" data-linked-resource-type="page">CAN BUS</a> page</li><li>Add the signals the message should contain</li><li>Add the boards that should transmit the message</li><li>Layout, arrange the signals to fit in the 8 bytes of the CAN message. The auto layout is likely ok</li></ol></li><li>Add the transmitters of the message<ol><li>Under network nodes, double click the node and go to tx messages, and add the message</li></ol></li><li>Add the receivers of the message<ol><li>In CANdb++, receiver are automatically assigned based on the nodes that receive one of the message signals. Therefore, add signals to be received to the desired nodes by double clicking on the node and selecting mapped Rx sig</li></ol></li><li>Save the dbc file, run make clean and make</li><li>Verify that the message shows up in the &lt;board_name&gt;_can.h and &lt;board_name&gt;_can.c files.<ol><li>Common issue - forgetting to add the board as a transmitter of the message</li></ol></li><li>Once you have tested sending the message, commit the change (following the firmware <a href="9551872696.html" data-linked-resource-id="9551872696" data-linked-resource-version="6" data-linked-resource-type="page">Firmware Workflow (using Git)</a>). </li><li>Add appropriate code to receive the CAN message on other boards as necessary</li></ol></div>
</div>
</div>
<div class="columnLayout single" data-layout="single">
<div class="cell normal" data-type="normal">
<div class="innerCell">
<h1 id="CAN(ControlAreaNetwork)-DTC(DiagnosticTroubleCode)">DTC (Diagnostic Trouble Code)</h1><p>On top of the CAN network, the car uses the concept of diagnostic trouble codes (DTC). They are loosely based around the concept of DTCs in the automotive industry. These are a special type of CAN message sent out that describe faults that occur. They are sent out by the board that detects the fault to notify one or more other boards of the fault. </p><p>There is one DTC message per CAN node, which contains 3 signals to describe the DTC being sent. These signals are the DTC code which uniquely identifies the fault, the DTC severity which indicates how severe the fault is (from most to least severe, these are: 1- Fatal, 2 - Critical, 3 - Error, 4 - Warning), and the data which is used to send additional information about the DTC. All DTC sent are described in the csv file in the common-all repo called 'dtc.csv' located in the Data directory. This is used to autogenerate a header file for each board to allow sending the DTC that that board generates. The python script 'generateDTC.py' in the common-all Scripts directory parses the dtc.csv file and generates the &lt;board_name&gt;_dtc.h file in the boards Gen/Inc directory.</p><h2 id="CAN(ControlAreaNetwork)-DTCSeverityMeanings">DTC Severity Meanings</h2><p>The meanings of the severity levels are:</p><ol><li>Fatal: An unrecoverable fault has occurred with high safety risks. The board detecting this fault must shut down in a safe manner immediately, and all other boards must also shut down in a safe manner immediately. To clear the fault, a power cycle must occur (and the fault should be manually diagnosed)</li><li>Critical: A fault has occurred with high safety risks. The board detecting the fault must take immediate action to handle the fault, either by shutting down or clearing the fault in some other manner. In general other boards don't need to take action, but depending on the fault some other boards may need to take action. This does not require a power cycle to clear.</li><li>Error: A fault has occurred with low safety risks. The board should take action to handle the fault, but action may not be necessary or need to immediately occur depending on the fault. In general other boards don't need to take action, but depending on the fault some other boards may need to take action. This does not require a power cycle to clear.</li><li>Warning: A condition has been detected that may cause a fault in the near future. No action is necessary at this moment, but precautions should be taken to avoid the condition escalating into a more severe fault. In general other boards don't need to take action, but depending on the condition some other boards may need to take action. This does not require a power cycle to clear.</li></ol><h2 id="CAN(ControlAreaNetwork)-SendingDTCmessages">Sending DTC messages</h2><p>To send DTC messages, use one of the macros in the autogenerated &lt;board_name&gt;_dtc.h This file contains a number of macros called sendDTC_&lt;severity&gt;_&lt;dtc_name&gt;(), with one macro for every DTC that has the board listed in the origin list in dtc.csv. If the board isn't listed in the origin list, add it and recompile to be able to send the DTC.</p><h2 id="CAN(ControlAreaNetwork)-ReceivingDTCMessages">Receiving DTC Messages</h2><p>There are two ways to receive DTCs. First, similar to other CAN messages there is a general callback for all DTCs from a specific board. Unlike other CAN callbacks, these have as parameters to the callback the DTC code, severity, and data of the received DTC. Second, there is a special DTC_Fatal_Callback. This is called whenever a fatal DTC is received from any board (other than the current board). This has as a parameter the board ID of the boar that sent the DTC. This method allows for easier handling of fatal DTCs. All boards should implement the fatal callback, as fatal DTCs require the board to immediately perform a safe shutdown. </p><p>Of the two methods to receive DTCs, use the first method of the general callback for all DTCs except for fatal DTCs, and use the fatal callback for fatal DTCs.</p><p>In addition to the two ways of receiving DTCs, the &lt;board_name&gt;_dtc.h file contains an enum of all the DTCs the board is specified as receiving in dtc.csv, mapping the name to the DTC code. As well, there is an enum mapping the severity names to the severity numerical values. In all cases, the names of DTCs and severities should be used instead of their numerical values.</p><h2 id="CAN(ControlAreaNetwork)-AddinganewDTC">Adding a new DTC</h2><p>In order to add a new DTC, the dtc.csv file is modified. The steps are as follows:</p><ol><li>Open the dtc.csv file in the repository of the board you want to send the DTC (if more than one board sends the DTC, simply choose one of them). It is a normal csv file, so can be opened with excel (or other spreadsheet software)</li><li>Add a new row to the file for the new DTC. The DTC code should simply increment the previous row's code (eg, previous row had ID 30, new DTC ID is 31)</li><li>Fill in the remainder of the columns describing the DTC<ol><li>Name: A name for the DTC describing the fault the DTC represents</li><li>Origin: One or more boards that send the DTC</li><li>Severity: The severity of the DTC, see the above section on DTC Severity Meanings</li><li>Subscribers: The boards that should be notified of the DTC. For fatal DTCs, this should be all boards (PDU, DCU, VCU_F7, VCU_BEAGLEBONE, BMU). Note it is optional to include the VCU_BEAGLEBONE in the subscriber list, as it receives all DTCs anyways.</li><li>Data: optional, allows sending up to 32 bits of data with the DTC. If used, give a descriptive name for the data in this field, and add more description in the message field</li><li>Message: A text string describing the DTC in more detail. If using the Data field, describe it here</li></ol></li><li>Save the DTC file (keep it in csv format, don't convert to excel format)</li><li>run make clean and make, and check that the new DTC shows up in the &lt;board_name&gt;_dtc.h </li><li>Once you have tested sending the DTC, commit the change (following the firmware <a href="9551872696.html" data-linked-resource-id="9551872696" data-linked-resource-version="6" data-linked-resource-type="page">Firmware Workflow (using Git)</a>). </li><li>Add appropriate error handling to other boards that receive the DTC as necessary</li></ol></div>
</div>
</div>
<div class="columnLayout single" data-layout="single">
<div class="cell normal" data-type="normal">
<div class="innerCell">
<h1 id="CAN(ControlAreaNetwork)-CANBittimingsite">CAN Bit timing site</h1><p>You can use this site to calculate the bit timing parameters for configuring the Cube CAN driver:</p><p><a class="external-link" href="http://bittiming.can-wiki.info" rel="nofollow">http://bittiming.can-wiki.info</a></p><p><br/></p><p>NB: that Cube automatically handles the +1 for prescaler and bit segments specified in the data sheet. If you don't understand this then this just means put the number from the site directly into cube.</p></div>
</div>
</div>
</div>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Oct 15, 2022 02:51</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
